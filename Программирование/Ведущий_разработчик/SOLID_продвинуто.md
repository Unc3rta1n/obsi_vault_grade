Принципы SOLID являются основой для создания гибкого, расширяемого и поддерживаемого кода в объектно-ориентированном программировании. Когда вы переходите от базовых знаний к продвинутому уровню, важно понять, как эти принципы взаимосвязаны, как применять их в сложных сценариях и избегать типичных ошибок. Рассмотрим более углубленное применение каждого принципа.

### 1. **Single Responsibility Principle (Принцип единственной ответственности)**

На продвинутом уровне важно не только обеспечить единую ответственность класса, но и разделение ответственности на уровне пакетов или модулей. Это может включать в себя использование **доменных сервисов** и **утилит**, которые выполняют вспомогательные задачи, обеспечивая чистоту и ясность бизнес-логики.

#### Пример:
Если класс выполняет несколько разных ролей, его следует разделить на несколько классов с отдельными обязанностями. Однако следует учитывать баланс — слишком мелкие классы могут привести к избыточности и снижению читаемости кода.

```python
# Пример: Плохо
class User:
    def save(self):
        # Сохраняет пользователя в базу данных
        pass
    def send_welcome_email(self):
        # Отправляет приветственное письмо
        pass

# Пример: Хорошо
class UserRepository:
    def save(self, user):
        # Сохраняет пользователя в базу данных
        pass

class EmailService:
    def send_welcome_email(self, user):
        # Отправляет приветственное письмо
        pass
````

### 2. **Open/Closed Principle (Принцип открытости/закрытости)**

Принцип открытости/закрытости на продвинутом уровне предполагает, что вы не только можете расширять классы, но и применяете абстракции, которые позволяют изменять поведение системы, не внося изменения в существующий код. Это требует активного использования **полиморфизма** и **абстракций** (например, интерфейсов или абстрактных классов).

#### Пример:

Вместо изменения существующего кода можно создать расширения, которые позволяют адаптировать поведение без изменения исходных классов.

```python
from abc import ABC, abstractmethod

class Notification(ABC):
    @abstractmethod
    def send(self):
        pass

class EmailNotification(Notification):
    def send(self):
        # Логика отправки email
        pass

class SMSNotification(Notification):
    def send(self):
        # Логика отправки SMS
        pass

# Пример использования
def notify_users(notification: Notification):
    notification.send()

# Вызываем SMS или Email, не меняя код функции
notify_users(SMSNotification())
```

### 3. **Liskov Substitution Principle (Принцип подстановки Лисков)**

Принцип подстановки Лисков требует, чтобы наследуемые классы не изменяли поведение базового класса в непредсказуемом или нежелательном направлении. На продвинутом уровне это означает, что вы должны следить за тем, чтобы наследуемые классы корректно реализовывали методы базового класса, не нарушая бизнес-логику и контракт.

#### Пример:

Если вы расширяете базовый класс, важно следить, чтобы дочерний класс не нарушал основные требования и логику работы системы.

```python
class Bird:
    def fly(self):
        return "Flying"

class Penguin(Bird):
    def fly(self):
        raise NotImplementedError("Penguins can't fly")

# Принцип Лисков нарушен, так как попытка вызвать fly на Penguin вызовет ошибку.
```

Чтобы избежать таких нарушений, лучше применять **абстракции** и **интерфейсы**.

```python
class Bird(ABC):
    @abstractmethod
    def move(self):
        pass

class Sparrow(Bird):
    def move(self):
        return "Flying"

class Penguin(Bird):
    def move(self):
        return "Swimming"
```

### 4. **Interface Segregation Principle (Принцип разделения интерфейсов)**

На продвинутом уровне этот принцип часто используется в более сложных системах, где интерфейсы становятся многогранными. Вместо того, чтобы делать один гигантский интерфейс, который вынуждает все классы реализовывать лишние методы, следует создавать несколько специализированных интерфейсов, которые могут быть реализованы только нужными классами.

#### Пример:

Допустим, у вас есть интерфейс для операций с документами. Вместо того, чтобы делать интерфейс, который включает в себя методы для работы с PDF, DOC и HTML, создайте отдельные интерфейсы для каждой операции.

```python
class Document(ABC):
    @abstractmethod
    def print(self):
        pass

class PDFDocument(Document):
    def print(self):
        print("Printing PDF")

class HTMLDocument(Document):
    def print(self):
        print("Printing HTML")

class Printer(ABC):
    @abstractmethod
    def print(self, doc: Document):
        pass

class LaserPrinter(Printer):
    def print(self, doc: Document):
        doc.print()

# Такой подход позволяет разделить обязанности и избежать избыточных зависимостей.
```

### 5. **Dependency Inversion Principle (Принцип инверсии зависимостей)**

Продвинутый подход к этому принципу заключается в правильной настройке инъекций зависимостей и применении контейнеров зависимостей для управления зависимостями в масштабируемых приложениях. Это позволяет вам не жестко связывать классы с конкретными реализациями, а использовать абстракции и интерфейсы.

#### Пример:

Инъекция зависимостей позволяет улучшить тестируемость и гибкость кода.

```python
class DatabaseConnection:
    def connect(self):
        return "Connected to Database"

class Application:
    def __init__(self, db_connection: DatabaseConnection):
        self.db_connection = db_connection

    def perform_task(self):
        print(self.db_connection.connect())

# Внедрение зависимости
db_connection = DatabaseConnection()
app = Application(db_connection)
app.perform_task()
```

Инъекцию зависимостей можно улучшить с помощью **фреймворков для DI** (например, **dependency injector**).

### Заключение

Продвинутое понимание SOLID включает в себя умение правильно применять эти принципы в реальных проектах. Важно не просто следовать этим принципам на базовом уровне, но и понимать, как они могут быть использованы в сочетании с другими паттернами, такими как **Strategy**, **Factory**, **Observer** и другими, для создания гибкой и масштабируемой архитектуры. Понимание взаимосвязей и нюансов применения SOLID в крупных системах поможет улучшить качество кода и уменьшить количество ошибок в проектировании.